/*******************************************************************************
 * DARPA XDATA licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with 
 * the License.  You may obtain a copy of the License at 
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software 
 * distributed under the License is distributed on an "AS IS" BASIS, 
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and  
 * limitations under the License.
 * 
 * Copyright 2013 Raytheon BBN Technologies Corp. All Rights Reserved.
 ******************************************************************************/
/* =============================================================================
 *
 *                  COPYRIGHT 2010 BBN Technologies Corp.
 *                  1300 North 17th Street, Suite 600
 *                       Arlington, VA  22209
 *                          (703) 284-1200
 *
 *       This program is the subject of intellectual property rights
 *       licensed from BBN Technologies
 *
 *       This legend must continue to appear in the source code
 *       despite modifications or enhancements by any party.
 *
 *
 * ==============================================================================
 */
package com.bbn.c2s2.pint.pf.util;

import java.util.Random;

import no.uib.cipr.matrix.DenseVector;
import no.uib.cipr.matrix.Matrix;
import no.uib.cipr.matrix.Vector;

/**
 * Helper class for calculating the eigenvalues of a matrix 
 * @author reblace
 *
 */
public class PowerIteration {

	/**
	 * Approximates the eigenvalues of a matric
	 * @param A the matrix
	 * @return the eigenvalues of the matrix
	 */
	public static Vector getEig(Matrix A) {
		final double EPSILON = 0.0000001;
		final long RANDOM_SEED = 54;

		double[] lamEst = new double[2];
		lamEst[0] = 0;
		lamEst[1] = Double.MAX_VALUE;
		int size = A.numColumns();
		Vector eigEst = getInitialRandomVector(RANDOM_SEED, size);
		Vector tmp = new DenseVector(eigEst);
		while (Math.abs(lamEst[0] - lamEst[1]) > EPSILON) {
			Vector j = new DenseVector(eigEst);
			A.mult(eigEst, j);
			eigEst = j;
			double norm = eigEst.norm(Vector.Norm.Two);
			eigEst = eigEst.scale(1 / norm);
			A.mult(eigEst, tmp);
			double newLamEst = eigEst.dot(tmp);
			lamEst[1] = lamEst[0];
			lamEst[0] = newLamEst;
		}
		return eigEst;
	}

	/**
	 * Creates a random vector with a given size and initialized to double 
	 * values generated by a random number generated using the provided seed 
	 * @param seed The seed to use for the number generator
	 * @param size The size of the vector
	 * @return the vector
	 */
	private static Vector getInitialRandomVector(long seed, int size) {
		double[] t = new double[size];
		Random gen = new Random(seed);
		for (int i = 0; i < size; i++)
			t[i] = gen.nextDouble();

		return new DenseVector(t);
	}

}
